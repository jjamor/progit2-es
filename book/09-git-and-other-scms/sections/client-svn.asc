[[_git_svn]]
==== Git y Subversion

(((Subversion)))(((Interoperabilidad con otros VCS, Subversion)))
Muchos proyectos de código abierto y corporativos utilizan Subversion para gestionar el código fuente.
Ha sido el sistema más popular durante más de una década, siendo el estándar de facto para VCS en el caso
de proyectos libres. También es muy similar en muchas cosas a CVS, que fue el rey del control de código fuente anteriormente.

(((comandos de git, svn)))(((git-svn)))
Una de las grandes características de Git es el puente bidireccional llamado `git svn`. Esta herramienta
permite el uso de Git como un cliente válido para un servidor Subversion, así que puedes utilizar todas
las características locales de Git y luego hacer publicaciones al servidor de Subversion como si
estuvieras usando Subversion localmente. Esto significa que puedes ramificar y fusionar localmente, usar
el área de preparación, reconstruir, entresacar, etc., mientras tus colaboradores continúan usando sus
antiguos y oscuros métodos. Es una buena forma de colar a Git dentro de un ambiente corporativo y ayudar a
tus colegas desarrolladores a hacerse más eficientes mientras tu haces presión para que se cambie la
infraestructura y el soporte de Git sea completo. El puente de Subversion es la "droga de entrada" al
mundo de DVCS.

===== `git svn`

El comando básico de Git para todos los comandos de enlace con Subversion es `git svn`. Hay unos cuantos,
por lo que vamos a aprender los básicos recorriendo unos pocos flujos de trabajo pequeños.

Es importante fijarse en que cuando usas `git svn` estás interactuando con Subversion, que es un sistema
mucho menos sofisticado que Git. Aunque puedes hacer ramas y fusiones localmente, lo mejor es mantener tu
historia lo más lineal posible mediante reorganizaciones, y evitar hacer cosas como interactuar a la vez
con un repositorio remoto de Git.

No reescribas tu historia y trates de publicar de nuevo, y no publiques a un repositorio Git paralelo para
colaborar con colegas que usen Git al mismo tiempo. Subversion sólo puede tener una historia lineal
simple, de lo contrario puedes confundirlo fácilmente. Si trabajas con un equipo, y algunos usan SVN
mientras otros usan Git, asegúrate de que todos usan el servidor de SVN para colaborar. Si lo haces así,
tu vida será más simple.

===== Puesta en marcha

Para probar esta funcionalidad, necesitamos un repositorio subversion donde tengamos acceso de escritura.
Para probar estos ejemplos, será necesario realizar una copia de mi repositorio de pruebas. Para hacerlo
de forma sencilla, se puede usar la utilidad `svnsync` que viene con Subversion. Para las pruebas, hemos
creado un repositorio en Google Code con una copia parcial del proyecto `protobuf`, una utilidad que
codifica datos estructurados para enviarlos por red.

Para hacer la prueba, en primer lugar hay que crear un repositorio local Subversion:

[source,console]
----
$ mkdir /tmp/test-svn
$ svnadmin create /tmp/test-svn
----

A continuación, permitir a todos los usuarios el cambio de revprops. La forma sencilla es añadir un script
`pre-revprop-change` que siempre retorne 0:

[source,console]
----
$ cat /tmp/test-svn/hooks/pre-revprop-change
#!/bin/sh
exit 0;
$ chmod +x /tmp/test-svn/hooks/pre-revprop-change
----

Ya podemos configurar la sincronización con el proyecto en la máquina usando `svnsync init`:

[source,console]
----
$ svnsync init file:///tmp/test-svn \
  http://progit-example.googlecode.com/svn/
----

Esto prepara las propiedades para ejecutar la sincronización. Ahora se puede clonar el código
ejecutando:

[source,console]
----
$ svnsync sync file:///tmp/test-svn
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .............................[...]
Committed revision 2.
Copied properties for revision 2.
[…]
----

Aunque esta operación pueda tardar poco, si intentamos copiar el repositorio original a otro repositorio
también remoto, en lugar de uno local, el proceso puede tardar casi una hora, aunque tenga menos de 100
commits. Subversion tiene que clonar cada revisión una a una, y entonces enviarla al otro repositorio. Esto
es muy ineficiente, pero es la única forma de hacerlo.

===== Comenzando el trabajo

Ahora que tenemos un repositorio Subversion donde podemos escribir, podemos seguir un flujo de trabajo
típico. Primero, empezamos con el comando `git svn clone`, que importa el repositorio Subversion en un
repositorio local. Hay que recordar que si estamos importando desde un repositorio Subversion real, tenemos 
que sustituir `file:///tmp/test-svn` por la URL del repositorio que vayamos a importar:

[source,console]
----
$ git svn clone file:///tmp/test-svn -T trunk -b branches -t tags
Initialized empty Git repository in /private/tmp/progit/test-svn/.git/
r1 = dcbfb5891860124cc2e8cc616cded42624897125 (refs/remotes/origin/trunk)
    A	m4/acx_pthread.m4
    A	m4/stl_hash.m4
    A	java/src/test/java/com/google/protobuf/UnknownFieldSetTest.java
    A	java/src/test/java/com/google/protobuf/WireFormatTest.java
…
r75 = 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae (refs/remotes/origin/trunk)
Found possible branch point: file:///tmp/test-svn/trunk => file:///tmp/test-svn/branches/my-calc-branch, 75
Found branch parent: (refs/remotes/origin/my-calc-branch) 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae
Following parent with do_switch
Successfully followed parent
r76 = 0fb585761df569eaecd8146c71e58d70147460a2 (refs/remotes/origin/my-calc-branch)
Checked out HEAD:
  file:///tmp/test-svn/trunk r75
----

El comando equivale a dos comandos: `git svn init`, seguido de `git svn fetch` sobre la URL proporcionada,
y puede tardar un rato. El proyecto de prueba tan solo tiene unos 75 commits y la base de código no es
grande, pero Git tiene que comprobar cada versión, una a una, y hacer commit por cada una de ellas
individualmente. Para un proyecto con cientos o miles de commits, esto puede tardar horas o incluso
días.

Las opciones `-T trunk -b branches -t tags` indican a Git que este repositorio Subversion sigue las
convenciones habituales para las ramas y el etiquetado. Si no las seguimos, hay que cambiar las opciones.
Dado que estas convenciones son muy habituales, lo anterior se puede reemplazar simplemente por la opción
`-s`, que corresponde con un layout estándar. Por tanto, este comando es equivalente:

[source,console]
----
$ git svn clone file:///tmp/test-svn -s
----

Cuando finalice el proceso, tendremos un repositorio Git válido con las ramas y etiquetas:

[source,console]
----
$ git branch -a
* master
  remotes/origin/my-calc-branch
  remotes/origin/tags/2.0.2
  remotes/origin/tags/release-2.0.1
  remotes/origin/tags/release-2.0.2
  remotes/origin/tags/release-2.0.2rc1
  remotes/origin/trunk
----

Observamos que esta utilidad gestiona las etiquetas de Subversion como referencias remotas.
(((git commands, show-ref)))

Lo veremos más claro con el comando avanzado `show-ref`:

[source,console]
----
$ git show-ref
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/heads/master
0fb585761df569eaecd8146c71e58d70147460a2 refs/remotes/origin/my-calc-branch
bfd2d79303166789fc73af4046651a4b35c12f0b refs/remotes/origin/tags/2.0.2
285c2b2e36e467dd4d91c8e3c0c0e1750b3fe8ca refs/remotes/origin/tags/release-2.0.1
cbda99cb45d9abcb9793db1d4f70ae562a969f1e refs/remotes/origin/tags/release-2.0.2
a9f074aa89e826d6f9d30808ce5ae3ffe711feda refs/remotes/origin/tags/release-2.0.2rc1
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/remotes/origin/trunk
----

Cuando se hace un clonado de un repositorio Git, el comportamiento es diferente. Por ejemplo, si tenemos
un repositorio Git local clonado de un repositorio Git remoto, tendremos esto:

[source,console]
----
$ git show-ref
c3dcbe8488c6240392e8a5d7553bbffcb0f94ef0 refs/remotes/origin/master
32ef1d1c7cc8c603ab78416262cc421b80a8c2df refs/remotes/origin/branch-1
75f703a3580a9b81ead89fe1138e6da858c5ba18 refs/remotes/origin/branch-2
23f8588dde934e8f33c263c6d8359b2ae095f863 refs/tags/v0.1.0
7064938bd5e7ef47bfd79a685a62c1e2649e2ce7 refs/tags/v0.2.0
6dcb09b5b57875f334f61aebed695e2e4193db5e refs/tags/v1.0.0
----

Git obtiene las etiquetas directamente bajo `refs/tags`, en lugar de considerarlas ramas remotas.

===== Re-enviando los commits a Subversion

Ahora que tenemos un repositorio funcional, podemos hacer algunos cambios y enviarlos de nuevo a nuestro
repositorio aguas arriba, usando Git como un cliente SVN.
Si editamos cualquier fichero y hacemos commit, tendremos un commit que existe en Git localmente pero no en
el repositorio Subversion:

[source,console]
----
$ git commit -am 'Adding git-svn instructions to the README'
[master 4af61fd] Adding git-svn instructions to the README
 1 file changed, 5 insertions(+)
----

Es necesario enviar (push) los cambios aguas arriba. Obsérvese la diferencia: cuando hacemos commit con Git,
los cambios se hacen offline y al final se envían todos juntos al servidor Subversion. Para ello, se usa
el comando `git svn dcommit`:

[source,console]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r77
    M	README.txt
r77 = 95e0222ba6399739834380eb10afcd73e0670bc5 (refs/remotes/origin/trunk)
No changes between 4af61fd05045e07598c553167e0f31c84fd6ffe1 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk
----

Este comando toma todos los commits locales y realiza un commit Subversion para cada uno, para luego 
modificar el repositorio Git local de forma consistente, con un único identificador. Esto es importante: 
el hecho de que vengan identificados con un checksum SHA-1, hace que no sea buena idea que varios
usuarios trabajen con Git contra el mismo repositorio Subversion.
Si miramos el log del último commit, veremos que se añadió un `git-svn-id`:

[source,console]
----
$ git log -1
commit 95e0222ba6399739834380eb10afcd73e0670bc5
Author: ben <ben@0b684db3-b064-4277-89d1-21af03df0a68>
Date:   Thu Jul 24 03:08:36 2014 +0000

    Adding git-svn instructions to the README

    git-svn-id: file:///tmp/test-svn/trunk@77 0b684db3-b064-4277-89d1-21af03df0a68
----

El checksum SHA-1 original empezaba con `4af61fd`, pero ahora empieza con `95e0222`. Si queremos enviar
a la vez a un servidor Git y a un servidor Subversion, tenemos que hacer `dcommit` contra Subversion en
primer lugar, ya que esta acción cambia los datos del commit.

===== Descarga de cambios en remoto

Si estamos trabajando con otros desarrolladores, en algun momento habrá dos que intenten enviar commits y entren en conflicto. El cambio será rechazado hasta que se resuelva. En `git svn` se ve así:

[source,console]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File '/trunk/README.txt' is out of date
W: d5837c4b461b7c0e018b49d12398769d2bfc240a and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 f414c433af0fd6734428cf9d2a9fd8ba00ada145 c80b6127dd04f5fcda218730ddf3a2da4eb39138 M	README.txt
Current branch master is up to date.
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.
----

Para resolver este problema, se puede hacer un `git svn rebase`, que se baja todos los cambios del servidor
que no tenemos aun y reorganiza con todo el trabajo que hayamos realizado posteriormente:

[source,console]
----
$ git svn rebase
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File '/trunk/README.txt' is out of date
W: eaa029d99f87c5c822c5c29039d19111ff32ef46 and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 65536c6e30d263495c17d781962cfff12422693a b34372b25ccf4945fe5658fa381b075045e7702a M	README.txt
First, rewinding head to replay your work on top of it...
Applying: update foo
Using index info to reconstruct a base tree...
M	README.txt
Falling back to patching base and 3-way merge...
Auto-merging README.txt
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.
----

Ahora, todo el trabajo realizado por nosotros sí puede enviarse a Subversion, con `dcommit`:

[source,console]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r85
    M	README.txt
r85 = 9c29704cc0bbbed7bd58160cfb66cb9191835cd8 (refs/remotes/origin/trunk)
No changes between 5762f56732a958d6cfda681b661d2a239cc53ef5 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk
----

Observemos que, a diferencia de Git, que requiere fusionar con la versión de aguas arriba antes de enviar,
`git svn` lo hace solo si el cambio tiene conflicto (igual como lo hace Subversion). Si alguien más envía
cambios a un fichero y luego nosotros enviamos cambios a otro fichero, el comando `dcommit` funcionará
perfectamente:

[source,console]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	configure.ac
Committed r87
    M	autogen.sh
r86 = d8450bab8a77228a644b7dc0e95977ffc61adff7 (refs/remotes/origin/trunk)
    M	configure.ac
r87 = f3653ea40cb4e26b6281cec102e35dcba1fe17c4 (refs/remotes/origin/trunk)
W: a0253d06732169107aa020390d9fefd2b1d92806 and refs/remotes/origin/trunk differ, using rebase:
:100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 e757b59a9439312d80d5d43bb65d4a7d0389ed6d M	autogen.sh
First, rewinding head to replay your work on top of it...
----

Esto es importante de recordar, ya que el resultado es un estado del proyecto que no existía en nuestro
ordenador cuando se envió. Si los cambios son incompatibles pero no entran en conflicto, se pueden 
ocasionar problemas difíciles de diagnosticar. Esto es diferente a cuando se usa un servidor Git: en Git, se
puede comprobar el estado del cliente antes de enviar cambios, mientras que en Subversion, no se puede
confirmar que el estado inmediatamente anterior antes del commit y posterior sea el mismo.

También debemos ejecutar este comando para recibir cambios desde el servidor Subversion, aunque no
estemos preparados para hacer commit. Se puede ejecutar `git svn fetch` para obtener los nuevos datos, pero
con `git svn rebase` se hace la extracción y luego actualización de commits locales.

[source,console]
----
$ git svn rebase
    M	autogen.sh
r88 = c9c5f83c64bd755368784b444bc7a0216cc1e17b (refs/remotes/origin/trunk)
First, rewinding head to replay your work on top of it...
Fast-forwarded master to refs/remotes/origin/trunk.
----

De este modo, si ejecutamos `git svn rebase` cada vez que vayamos a trabajar, estaremos seguros
de estar actualizados. Necesitamos asegurarnos de que la copia de trabajo está limpia antes de ejecutar
el comando. Si hay cambios locales, habrá que esconder nuestro trabajo o temporalmente hacer commit antes
del `git svn rebase`. De otro modo, el comando fallará si ve algún conflicto en la fusión.

===== Incidencias con las ramificaciones de Git

Cuando estamos a gusto con un flujo de trabajo de Git, lo normal es que se creen ramas, se trabaje en
ellas y se hagan posteriormente fusiones (merge). Si estamos subiendo cambios a un servidor Subversion
con `git svn`, seguramente querremos reorganizar el trabajo en una sola rama cada vez, en lugar de 
fusionar varias. La razón para preferir la reorganización es que Subversion tiene un historial lineal, y 
no gestiona las fusiones como lo hace Git, por lo que `git svn` sigue solo al primer antecesor cuando
se convierten las instantáneas en commits de subversion.

Supongamos que la historia tiene el siguiente aspecto; habiendo creado una rama llamada `experiment`,
haciendo dos commits, y luego fusionarlo en `master`. Cuando hagamos `dcommit`, se verá
una salida similar a esta:

[source,console]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	CHANGES.txt
Committed r89
    M	CHANGES.txt
r89 = 89d492c884ea7c834353563d5d913c6adf933981 (refs/remotes/origin/trunk)
    M	COPYING.txt
    M	INSTALL.txt
Committed r90
    M	INSTALL.txt
    M	COPYING.txt
r90 = cb522197870e61467473391799148f6721bcf9a0 (refs/remotes/origin/trunk)
No changes between 71af502c214ba13123992338569f4669877f55fd and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk
----

Cuando se ejecuta `dcommit` en una rama con el historial fusionado, funciona correctamente,
salvo que cuando miramos en el historial de Git, no habrá reescrito ninguno de los commits
hechos en la rama `experimient`, sino que en su lugar aparecen los cambios de SVN como un 
commit de fusión.

Cuando alguien clona el trabajo, todo lo que verá es el commit de fusión todo el trabajo dentro, igual
que si hubiéramos hecho `git merge --squash`, y no se verán los commits de los que procede la fusión, o
cuándo fue realizado cada cambio.

===== Ramas con Subversion

Las ramas en Subversion no son lo mismo que las ramas de Git. Si puedes evitarlas, será probablemente
lo mejor. Sin embargo, se puede crear y enviar cambios a las ramas de Subversion utilizando `git svn`.

===== Creación de una nueva rama SVN

Para crear una nueva rama en Subversion, ejecutamos `git svn branch [nombre-de-la-rama]`:

[source,console]
----
$ git svn branch opera
Copying file:///tmp/test-svn/trunk at r90 to file:///tmp/test-svn/branches/opera...
Found possible branch point: file:///tmp/test-svn/trunk => file:///tmp/test-svn/branches/opera, 90
Found branch parent: (refs/remotes/origin/opera) cb522197870e61467473391799148f6721bcf9a0
Following parent with do_switch
Successfully followed parent
r91 = f1b64a3855d3c8dd84ee0ef10fa89d27f1584302 (refs/remotes/origin/opera)
----

Esto hace lo mismo que `svn copy trunk branches/opera` y actúa sobre el servidor Subversion.
Es importante observar que no nos hace una copia local de la rama. Si hacemos commit a continuación,
éste irá a parar de nuevo a la rama `trunk`.

===== Cambio de la Rama Actual

Git deduce la rama a las que van los dcommits a partir de la historia y ramas de subversion (donde solo debería haber una con el valor correcto de `git-svn-id` en el historial).

Si queremos trabajar en más de una rama simultáneamente, se pueden configurar ramas locales para hacer
`dcommit` hacia ramas específicas de Subversion, iniciándolas en el commit de Subversion importado para
dicha rama.

[source,console]
----
$ git branch opera remotes/origin/opera
----

Si ahora queremos fusionar la rama `opera` en `trunk` (nuestra rama `master`), se puede hacer con un `git
merge` normal. Pero hay que dar un mensaje de commit descriptivo (con la opción `-m`), o el fusionado dirá
``Merge branch opera'' en lugar de algo más útil para nosotros.

Recordar que aunque usemos `git merge`, y la fusión sea más sencilla que en Subversion (ya que Git
automáticamente detecta la base de fusión), no estamos con un commit de fusión normal de Git.
Hay que enviar esta información al servidor SVN que no puede gestionar commits que tienen más de un padre;
por lo que después de enviarlo, buscará un commit único que reúna todos los de una rama.
Tras fusionar una rama en otra, no se puede volver atrás fácilmente y continuar trabajando en la rama, como
se haría en Git.
El comando `dcommit` que estamos usando, borra cualquier información que diga qué rama fue fusionada,
por lo que los subsiguientes cálculos basados en fusión con base serán incorrectos. El dcommit hace que el
`git merge` sea similar a un `git merge --squash`.
Por desgracia, no hay una forma fácil de evitar este problema, ya que Subversion no puede almacenar esta
información. Por tanto hay que considerar estas limitaciones siempre que usemos Subversion. Para evitar
problemas, se debe borrar la rama local (en este caso, `opera') tras fusionarla en trunk.

===== Comandos de Subversion

En `git svn` tenemos una colección de comandos que facilitan la transición a Git desde Subversion. A continuación, vemos algunos de esos comandos.

====== Historial estilo SVN

Si hemos usado Subversion y queremos ver el historial en formato SVN, podemos usar `git svn log`:

[source,console]
----
$ git svn log
------------------------------------------------------------------------
r87 | schacon | 2014-05-02 16:07:37 -0700 (Sat, 02 May 2014) | 2 lines

autogen change

------------------------------------------------------------------------
r86 | schacon | 2014-05-02 16:00:21 -0700 (Sat, 02 May 2014) | 2 lines

Merge branch 'experiment'

------------------------------------------------------------------------
r85 | schacon | 2014-05-02 16:00:09 -0700 (Sat, 02 May 2014) | 2 lines

updated the changelog
----

Hay que tener en cuenta dos cosas importantes acerca de `git svn log`. En primer lugar, funciona sin
conexión, a diferencia del comando `svn log` real, que pide al servidor Subversion todos los datos cada
vez. En segundo lugar, solo muestra los commits que han sido enviados al servidor Subversion. Los commits
Git locales que no se han enviado con `dcommit` no se muestran, ni tampoco los que hayan sido enviados por
otras personas a Subversion mientras tanto. Es más algo como el último estado conocido del servidor
Subversion.

====== SVN Anotación

Al igual que `git svn log` simula el comando `svn log` pero sin conexión, se puede obtener algo similar a
`svn annotate` con `git svn blame [FICHERO]`. La salida será similar a:

[source,console]
----
$ git svn blame README.txt
 2   temporal Protocol Buffers - Google's data interchange format
 2   temporal Copyright 2008 Google Inc.
 2   temporal http://code.google.com/apis/protocolbuffers/
 2   temporal
22   temporal C++ Installation - Unix
22   temporal =======================
 2   temporal
79    schacon Committing in git-svn.
78    schacon
 2   temporal To build and install the C++ Protocol Buffer runtime and the Protocol
 2   temporal Buffer compiler (protoc) execute the following:
 2   temporal
----

Y nuevamente, no mostrará los commits locales de Git que no hayan sido enviados a Subversion.

====== Información del servidor SVN

Se puede obtener la información de `svn info` con `git svn info`:

[source,console]
----
$ git svn info
Path: .
URL: https://schacon-test.googlecode.com/svn/trunk
Repository Root: https://schacon-test.googlecode.com/svn
Repository UUID: 4c93b258-373f-11de-be05-5f7a86268029
Revision: 87
Node Kind: directory
Schedule: normal
Last Changed Author: schacon
Last Changed Rev: 87
Last Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)
----

Es parecido a los comandos `blame` y `log` en el sentido de que corre sin conexión y muestra, por tanto,
la última información conocida.

====== Ignorar lo que Subversion Ignora

Si clonamos un repositorio Subversion que tiene en algún sitio las propiedades `svn:ignore`, seguramente
vamos a querer crear los ficheros `.gitignore` para evitar enviar ficheros que no deben enviarse. Con
`git svn` tenemos dos comandos para ayudarnos. El primero, es `git svn create-ignore`, que crea los ficheros
`.gitignore` automáticamente para la próxima vez que hagamos commit.

El segundo comando es `git svn show-ignore`, que nos muestra las líneas que habría que poner en un
fichero `.gitignore` para obtener el efecto deseado:

[source,console]
----
$ git svn show-ignore > .git/info/exclude
----

De esta forma, no ensuciaremos el proyecto SVN con ficheros `.gitignore`. Es una buena opción cuando somos
el único usuario de Git en un equipo de Subversion, y por tanto los compañeros de equipo no desean ver
esos ficheros `.gitignore` en el proyecto.

===== Git-Svn: Resumen

Las utilidades `git svn` son útiles cuando estamos obligados a usar un servidor Subversion, o bien
estamos en un equipo que necesita usar este tipo de servidor. 
The `git svn` tools are useful if you're stuck with a Subversion server, or are otherwise in a development environment that necessitates running a Subversion server. Debe considerarse un Git limitado, por lo que
deben seguirse estas recomendaciones:

* Mantener un historial lineal de Git que no contenga fusiones hechas con `git merge`. Reorganizar
cualquier cosa que hagamos fuera de la rama principal, en lugar de fusionar nuestros cambios con ésta.
* No configurar y colaborar en un servidor Git separado. Probablemente nos interese crear clones para los
nuevos desarrolladores, pero no se debe enviar nada que no tenga una entrada `git-svn-id`. Se puede añadir
un gancho (hook) `pre-receive` que compruebe que cada mensaje de commit tiene la palabra `git-svn-id` y
rechace los envíos que contengan commits sin esta palabra.

Si se siguen estas recomendaciones, será posible que trabajemos normalmente contra un servidor Subversion.
Sin embargo, si fuera posible migrar en el futuro a un servidor Git real, se simplificaría todo, y todo
el equipo saldría ganando.
