==== Git y TFS

(((Interoperabilidad con otros VCS, TFS)))
(((TFS)))((("TFVC", see="TFS")))
Git se está haciendo popular entre los desarrolladores de Windows. Además, si somos desarrolladores,
es probable que hayamos usado Microsoft Team Foundation Server (TFS).
TFS es una suite de colaboración que incluye seguimiento de fallos y características, soporte de
procesos para Scrum y otras metodologías, revisión de código y control de versiones. Hay cierta confusión
entre *TFS* y *TFVC*. El primero es el servidor, que soporta control del código fuente utilizando tanto Git
como su propio VCS especial, que también se conoce como *TFVC* (Team Foundation Version Control). El
soporte de Git es una nueva característica de TFS (añadida en 2013), por lo que cuando se habla del
control de versiones en fechas anteriores nos referimos a TFVC.

Si estamos en un equipo que usa TFVC pero queremos usar Git como cliente, este capítulo nos interesa.

===== Herramientas

(((git-tf)))(((git-tfs)))
Tenemos dos herramientas disponibles: git-tf y git-tfs.

Git-tfs (que podemos descargar en https://github.com/git-tfs/git-tfs[]) es un proyecto .NET, y, solo 
estaba disponible para Windows cuando escribimos este libro. Para trabajar con repositorios Git, utiliza
enlaces de .NET con libgit2, una implementación de Git orientada a la programación de herramientas que
es muy eficiente y permite mucha flexibilidad con los repositorios Git. Libgit2 no es una implementación
completa de Git, por lo que en ocasiones será necesaria la línea de comando de Git para hacer algunas
operaciones, además de git-tfs. El soporte a las características de TFVC es muy maduro, ya que utiliza las
herramientas disponibles en Visual Studio. Esto significa que tenemos que instalar una versión reciente
de Visual Studio (incluyendo la versión Express de 2012) o el kit de desarrollo (SDK) de Visual Studio.

Git-tf (disponible en https://gittf.codeplex.com[]) es un proyecto Java, por lo que funciona en cualquier
ordenador con Java. Se conecta con los repositorios Git a través de JGit (una implementación en Java de
Git), por lo que casi no tiene ninguna limitación en términos de funciones Git. Sin embargo, su soporte 
de TFVC es limitado, comparado con git-tfs. Por ejemplo, no soporta las ramas.

Así pues, cada herramienta tiene sus pros y contras, y hay situaciones en las que nos decantaremos por una
o por otra. Aquí veremos ambas herramientas, en lo referente a un uso básico.

[NOTE]
====
Necesitamos acceso a un repositorio tipo TFVC para poder probar lo que veremos a continuación. Por
lo general, la única opción es crearnos uno, para lo que podemos usar Codeplex
(https://www.codeplex.com[]) o Visual Studio Online (http://www.visualstudio.com[]).
====


===== Comenzando con `git-tf`

Lo primero que haremos, como en cualquier proyecto Git, es clonar. Para ello:

[source,console]
----
$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main project_git
----

El primer argumento es la URL de una colección TFVC, el segundo es de la forma `$/proyecto/rama`, y el
tercero es la ruta local que se va a crear (este último es opcional). Git-tf puede trabajar con una 
rama a la vez; si queremos modificar ficheros en varias ramas TFVC, habrá que realizar un clonado por cada
una de las ramas.

El comando crea un repositorio Git completamente funcional, como puede verse:

[source,console]
----
$ cd project_git
$ git log --all --oneline --decorate
512e75a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Checkin message
----

Es un clon _superficial_ (shallow), que significa que solo nos bajamos el último conjunto de cambios
(changeset). TFVC no está diseñado para que cada usuario tenga una copia completa del historial, por lo que
git-tf obtiene, de manera predeterminada, la versión más reciente, lo que además es muy rápido.

Utilizando la opción `--deep` podemos clonar el historial completo, aunque tardará bastante tiempo:

[source,console]
----
$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main \
  project_git --deep
Username: domain\user
Password:
Connecting to TFS...
Cloning $/myproject into /tmp/project_git: 100%, done.
Cloned 4 changesets. Cloned last changeset 35190 as d44b17a
$ cd project_git
$ git log --all --oneline --decorate
d44b17a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Goodbye
126aa7b (tag: TFS_C35189)
8f77431 (tag: TFS_C35178) FIRST
0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
        Team Project Creation Wizard
----

Respecto a las etiquetas con nombres similares a `TFS_C35189`, corresponden a una característica que ayuda
a saber la relación entre commits de Git y changesets de TFVC. Son útiles para poderlos ver mediante 
`git log`, pero no son realmente necesarios (y de hecho, podemos evitarlos con el comando
`git config git-tf.tag false`), ya que la relación entre commits y changesets se guarda en el fichero
`.git/git-tf`.


===== Comenzando con `git-tfs`

El clonado con git-tfs es algo diferente, si observamos:

[source,powershell]
----
PS> git tfs clone --with-branches \
    https://username.visualstudio.com/DefaultCollection \
    $/project/Trunk project_git
Initialized empty Git repository in C:/Users/ben/project_git/.git/
C15 = b75da1aba1ffb359d00e85c52acb261e4586b0c9
C16 = c403405f4989d73a2c3c119e79021cb2104ce44a
Tfs branches found:
- $/tfvc-test/featureA
The name of the local branch will be : featureA
C17 = d202b53f67bde32171d5078968c644e562f1c439
C18 = 44cd729d8df868a8be20438fdeeefb961958b674
----

Vemos la opción `--with-branches`: Git-tfs puede hacer una correspondencia entre ramas TFVC y ramas de Git,
y esta opción permite crear una rama local Git por cada rama TFVC. Es algo recomendado, pero no funcionará
con un servidor más antiguo de TFS 2010, ya que antes de esta versión las ``ramas'' eran simplemente
carpetas.

Observando el repositorio Git resultante:

[source,powershell]
----
PS> git log --oneline --graph --decorate --all
* 44cd729 (tfs/featureA, featureA) Goodbye
* d202b53 Branched from $/tfvc-test/Trunk
* c403405 (HEAD, tfs/default, master) Hello
* b75da1a New project
PS> git log -1
commit c403405f4989d73a2c3c119e79021cb2104ce44a
Author: Ben Straub <ben@straub.cc>
Date:   Fri Aug 1 03:41:59 2014 +0000

    Hello

    git-tfs-id: [https://username.visualstudio.com/DefaultCollection]$/myproject/Trunk;C16
----

Aquí vemos dos ramas locales, `master` y `featureA`, que representa el punto de partida del clon 
(`Trunk` en TFVC) y una rama hija (`featureA` en TFVC). También puede verse que el remoto `tfs` tiene
un par de referencias: `default` y `featureA`, que representa a ramas TFVC. Git-tfs mapea la rama
clonada como `tfs/default`, y el resto tiene sus propios nombres.

Otra cosa a observar son las líneas `git-tfs-id:` en los mensajes de commit. En lugar de etiquetas,
git-tfs usa estos marcadores para relacionar los changeset de TFVC con los commits de Git. Esto significa
que el hash SHA-1 de los commits serán diferentes antes y después de enviar los cambios al servidor TFVC.

===== Flujos de trabajo con Git-tf[s]

[NOTE]
====
Independientemente de la herramienta que usemos, hay que poner un par de puntos en la configuración
de Git para evitar algunos problemas.

[source,console]
----
$ git config set --local core.ignorecase=true
$ git config set --local core.autocrlf=false
----
====

Una vez hecho el clonado, veremos cómo se trabaja con el proyecto. TFVC y TFS tiene varias características
que pueden complicar el flujo de trabajo:

. Ramas de características que no están representadas en TFVC añaden cierta complejidad. Esto tiene
que ver con la muy diferente forma de representar las ramas que tiene TFVC frente a Git.
. Hay que tener en cuenta que TFVC permite a los usuarios bajarse ficheros del servidor y bloquearlos
(``checkout'') evitando que cualquier otro los modifique. Esto no impedirá que lo editemos en la copia
local, pero no permitirá enviarlo después al servidor.
. TFS tiene el concepto de checkins ``gated'', donde se ha realizado un ciclo completo de compilación
y test antes de que se permita la subida del fichero cambiado. Para esto se usa la función de TFVC
``shelve'', que no detallaremos aquí. Se puede hacer manualmente con git-tf, mientras que git-tfs tiene
la utilidad `checkintool' que es compatible con `gate'.

En interés de la brevedad, veremos los casos de uso más evidentes, evitando casos de la complejidad
anterior.

===== Flujo de trabajo con `git-tf`

Supongamos que hacemos algo de trabajo, con un par de commits de Git en `master`, y queremos enviar ya
los cambios al servidor TFVC. En nuestro repositorio Git tenemos:

[source,console]
----
$ git log --oneline --graph --decorate --all
* 4178a82 (HEAD, master) update code
* 9df2ae3 update readme
* d44b17a (tag: TFS_C35190, origin_tfs/tfs) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

Queremos subir al servidor el commit `4178a82`. Lo primero es ver si alguien más ha cambiado cosas desde
que empezamos:

[source,console]
----
$ git tf fetch
Username: domain\user
Password:
Connecting to TFS...
Fetching $/myproject at latest changeset: 100%, done.
Downloaded changeset 35320 as commit 8ef06a8. Updated FETCH_HEAD.
$ git log --oneline --graph --decorate --all
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
| * 4178a82 (HEAD, master) update code
| * 9df2ae3 update readme
|/
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

Vemos que efectivamente han trabajado en el código y por tanto ahora tenemos una bifurcación en el
historial. Tenemos dos formas de proceder:

. Hacer un commit de fusión es algo natural con Git (después de todo, es lo que hace un `git pull`) y
git-tf lo puede hacer con un `git tf pull`. Hay que tener cuidado, sin embargo, de que TFVC no lo
gestiona igual y si enviamos los commits de fusión al servidor, el historial empezará a ser diferente en
ambos lados, lo que resultará confuso. De todas formas, si nuestra intención es subir nuestros cambios
en un solo changeset, esta será probablemente la forma más fácil de operar.
. La reorganización (rebase) hace el historial lineal, lo que significa que tenemos la opción de convertir
cada uno de los commits de Git en un changeset de TFVC. Dado que esto deja casi todas las opciones
abiertas, recomendamos hacerlo así; git-tf lo facilita con `git tf pull --rebase`.

La elección es nuestra. En este caso reorganizaremos:

[source,console]
----
$ git rebase FETCH_HEAD
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
$ git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

Ahora estamos listos para subir el cambio al servidor TFVC. Git-tf permite subirlo todo como un solo
changeset desde el último (`--shallow`, que es predeterminado) o crear un nuevo changeset por cada commit
de Git (`--deep`). Por ejemplo, agrupándolo todo en un changeset:

[source,console]
----
$ git tf checkin -m 'Updating readme and code'
Username: domain\user
Password:
Connecting to TFS...
Checking in to $/myproject: 100%, done.
Checked commit 5a0e25e in as changeset 35348
$ git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, tag: TFS_C35348, origin_tfs/tfs, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

Se crea una etiqueta `TFS_C35348`, lo que nos indica que TFVC ha almacenado exactamente el mismo
estado del código (snapshot) correspondiente al commit `5a0e25e`.
Es importante observar que no es necesario tener por cada commit de Git su equivalente en TFVC; por ejemplo,
el commit `6eb3eb5` no existe en el servidor.

Este es el flujo de trabajo principal. Hay algunas consideraciones adicionales a tener en cuenta:

* No hay ramas. Git-tf puede trabajar con repositorios Git desde una sola rama de TFVC a la vez.
* Tenemos que colaborar usando TFVC o Git, pero no con ambos. Diferentes clones de git-tf del mismo
repositorio TFVC puede tener diferentes hashes SHA-1 en los commits, lo que nos dará dolores de cabeza.
* Si el flujo de trabajo adoptado en el equipo incluye colaborar en Git y sincronizar periódicamente con
TFVC, solo conectar a TFVC con uno de los repositorios Git.

===== Flujo de trabajo con `git-tfs`

Repetimos el mismo escenario con git-tfs. Vemos en primer lugar los commits en Git:

[source,powershell]
----
PS> git log --oneline --graph --all --decorate
* c3bd3ae (HEAD, master) update code
* d85e5a2 update readme
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 (tfs/default) Hello
* b75da1a New project
----

Ahora vemos si alguien ha subido cambios al TFVC:

[source,powershell]
----
PS> git tfs fetch
C19 = aea74a0313de0a391940c999e51c5c15c381d91d
PS> git log --all --oneline --graph --decorate
* aea74a0 (tfs/default) update documentation
| * c3bd3ae (HEAD, master) update code
| * d85e5a2 update readme
|/
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Como vemos que sí hubo cambios, se nos muestra el commit nuevo `aea74a0` y la rama remota `tfs/default`
ha sido movida.

Al igual que con git-tf, hay dos formas principales de resolver la bifurcación del historial:

. Reorganizar para mantener un historial lineal.
. Fusionar para mantener todo lo sucedido.

En este caso, vamos a hacer un checkin ``deep'', en el que cada commit de Git se convierte en un changeset
de TFVC, por lo que vamos a reorganizar:

[source,powershell]
----
PS> git rebase tfs/default
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
PS> git log --all --oneline --graph --decorate
* 10a75ac (HEAD, master) update code
* 5cec4ab update readme
* aea74a0 (tfs/default) update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Ahora podemos completar nuestra contribución, subiéndola al servidor TFVC. Usaremos el comando
`rcheckin` para crear un changeset TFVC para cada commit en la ruta desde HEAD hasta la primera
rama remota `tfs` que se encuentre (el comando `checkin` crearía solo un changeset, haciendo algo parecido
a una unión de los commits de Git).

[source,powershell]
----
PS> git tfs rcheckin
Working with tfs remote: default
Fetching changes from TFS to minimize possibility of late conflict...
Starting checkin of 5cec4ab4 'update readme'
 add README.md
C20 = 71a5ddce274c19f8fdc322b4f165d93d89121017
Done with 5cec4ab4b213c354341f66c80cd650ab98dcf1ed, rebasing tail onto new TFS-commit...
Rebase done successfully.
Starting checkin of b1bf0f99 'update code'
 edit .git\tfs\default\workspace\ConsoleApplication1/ConsoleApplication1/Program.cs
C21 = ff04e7c35dfbe6a8f94e782bf5e0031cee8d103b
Done with b1bf0f9977b2d48bad611ed4a03d3738df05ea5d, rebasing tail onto new TFS-commit...
Rebase done successfully.
No more to rcheckin.
PS> git log --all --oneline --graph --decorate
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Observar que con cada subida exitosa al servidor TFVC, git-tfs reorganiza el trabajo restante. Y añade
el campo `git-tfs-id` al final de cada mensaje, lo que cambia los hashes SHA-1. Esto es así por diseño
y no tiene que preocuparnos, pero hay que tenerlo en cuenta, sobre todo si compartimos estos commits de
Git con otros.

TFS tiene muchas características para integrar con su propio sistema de control de versiones,
como items de trabajo, revisores designados, etc. Además, git-tfs permite lanzar una utilidad gráfica
de checkin fácilmente:

[source,powershell]
----
PS> git tfs checkintool
PS> git tfs ct
----

Que tiene el siguiente aspecto:

.Utilidad de checkin de git-tfs.
image::images/git-tfs-ct.png[Utilidad de checkin de git-tfs.]

Esto resulta conocido a los usuarios de TFS, puesto que es el mismo diálogo que se lanza desde
Visual Studio.

Git-tfs también permite controlar las ramas TFVC desde el repositorio Git.
Por ejemplo, creando una:

[source,powershell]
----
PS> git tfs branch $/tfvc-test/featureBee
The name of the local branch will be : featureBee
C26 = 1d54865c397608c004a2cadce7296f5edc22a7e5
PS> git log --oneline --graph --decorate --all
* 1d54865 (tfs/featureBee) Creation branch $/myproject/featureBee
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Crear una rama en TFVC significa añadir un changeset donde aparece la rama, y esto se nos proyecta como
un commit de Git. Observar que git-tfs ha creado la rama remota `tfs/featureBee`, pero `HEAD` aun apunta
a `master`. Si queremos trabajar sobre esta nueva rama, hay que basar los nuevos commits en el commit
`1d54865`, tal vez creando una rama desde dicho commit.


===== Resumen: Git y TFS.

Git-tf y Git-tfs son buenas herramientas para trabajar contra un servidor TFVC. Nos permite usar la
potencia de Git localmente, haciendo nuestra vida de desarrollador más simple, sin obligar a los demás
a usar Git. Si trabajamos con Windows (lo cual es probable en este caso), nos interesará git-tfs, puesto
que tiene más posibilidades. Pero si trabajamos en otra plataforma, tendremos que usar git-tf, más limitado
pero basado en Java. Como ocurre con casi todas las herramientas usadas en este capítulo, Git será usado
como sistema subordinado, siendo el otro (TFVC en este caso) el centro de la colaboración. No pueden 
ser ambos sistemas, Git y TFVC, centros de colaboración a la vez.
