==== Git and Perforce

(((Interoperabilidad con otros VCS, Perforce)))
(((Perforce)))
Perforce es un sistema de control de versiones bastante usado en entornos corporativos, existiendo desde
1995, siendo el más antiguo de los sistemas vistos en este capítulo. Está diseñado para las necesidades
de su época: asume que estamos conectados a un servidor central único y se guarda en disco local tan solo
una versión de los ficheros. Siendo sinceros, es un sistema que presenta muchas limitaciones, pero hay
muchos proyectos que lo usan y aquí Git podría mejorar mucho su gestión.

Hay dos formas de mezclar el uso de Perforce y Git. La primera es ``Git Fusion'', que permite 
mostrar partes del depósito Perforce como repositorios Git con lectura y escritura. La segunda es git-p4,
un puente en el cliente que permite usar Git como cliente de Perforce, sin necesitar más configuración en
el lado del servidor.

[[_p4_git_fusion]]
===== Git Fusion

(((Perforce, Git Fusion)))
Perforce tiene un producto llamado Git Fusion (disponible en http://www.perforce.com/git-fusion[]), que
sincroniza un servidor Perforce con repositorios Git, en el lado del servidor.

====== Puesta en marcha

En nuestros ejemplos, usaremos el método más simple para instalar Git Fusion, que consiste en descargar
una máquina virtual que corre el demonio de Perforce y Git Fusion. Esta máquina virtual puede
obtenerse en http://www.perforce.com/downloads/Perforce/20-User[], para luego importarla en el
software de virtualización que usemos (hemos probado a hacerlo con VirtualBox).

Al iniciar la máquina virtual, nos pedirá personalizar la contraseña de tres usuarios Linux (`root`,
`perforce`, and `git`), y dar un nombre a la instancia, que permite distinguir la instalación de otras
en la misma red. Una vez completados estos pasos, veremos esto:

.Pantalla de arranque de la máquian virtual de Git Fusion.
image::images/git-fusion-boot.png[Pantalla de arranque de la máquian virtual de Git Fusion.]

Hay que tomar nota de la IP que se muestra aquí, pues la utilizaremos después. A continuación crearemos
un usuario de Perforce. Seleccionamos la opción ``Login'' y pulsamos enter (o bien nos conectamos a la
máquina por SSH), y nos conectamos como `root`. A continuación, tecleamos los siguientes comandos para
crear el usuario:

[source,console]
----
$ p4 -p localhost:1666 -u super user -f john
$ p4 -p localhost:1666 -u john passwd
$ exit
----

El primer comando abre un editor VI para personalizar el usuario, aunque se pueden aceptar los valores
propuestos sin más que escribir `:wq` y pulsar enter. El segundo comando nos pedirá entrar la contraseña
dos veces. Esto es todo lo que tenemos que hacer en la shell, por lo que podemos salir de ella.

Lo siguiente es decir a Git que no verifique los certificados SSL. La imagen de Git Fusion trae
un certificado, pero no es válido para la IP de nuestra máquina virtual, por lo que Git rechazará conectarse
a ella con HTTPS. Si vamos a usar esta instalación de forma permanente, hay que consultar en el manual
de Git Fusion sobre cómo instalar otros certificados; pero para nuestro ejemplo, con esto nos valdrá:

[source,console]
----
$ export GIT_SSL_NO_VERIFY=true
----

Ahora ya podemos comprobar que todo funciona.

[source,console]
----
$ git clone https://10.0.1.254/Talkhouse
Cloning into 'Talkhouse'...
Username for 'https://10.0.1.254': john
Password for 'https://john@10.0.1.254':
remote: Counting objects: 630, done.
remote: Compressing objects: 100% (581/581), done.
remote: Total 630 (delta 172), reused 0 (delta 0)
Receiving objects: 100% (630/630), 1.22 MiB | 0 bytes/s, done.
Resolving deltas: 100% (172/172), done.
Checking connectivity... done.
----

La máquina virtual ya trae un ejemplo de proyecto que podemos clonar. Lo hemos hecho con HTTPS, y nos
pregunta credenciales de usuario y contraseña que luego quedarán en cache para no solicitarlas más veces.

====== Configuración de Fusion

Una vez que tenemos Git Fusion instalado, hay que configurarlo. Es fácil usando un cliente de Perforce.
Simplemente, hay que mapear el directorio `//.git-fusion` del servidor Perforce en nuestro espacio
de trabajo. El árbol de ficheros es similar a:

[source,console]
----
$ tree
.
├── objects
│   ├── repos
│   │   └── [...]
│   └── trees
│       └── [...]
│
├── p4gf_config
├── repos
│   └── Talkhouse
│       └── p4gf_config
└── users
    └── p4gf_usermap

498 directories, 287 files
----

La carpeta `objects` se utiliza internamente para mapear objetos de Perforce con Git y viceversa, no hay
que preocuparse más por su contenido. Hay un fichero `p4gf_config` global, así como uno similar en cada
repositorio; y se trata del fichero que establece el comportamiento de Git Fusion. Si miramos el contenido
de este fichero en la raíz:

[source,ini]
----
[repo-creation]
charset = utf8

[git-to-perforce]
change-owner = author
enable-git-branch-creation = yes
enable-swarm-reviews = yes
enable-git-merge-commits = yes
enable-git-submodules = yes
preflight-commit = none
ignore-author-permissions = no
read-permission-check = none
git-merge-avoidance-after-change-num = 12107

[perforce-to-git]
http-url = none
ssh-url = none

[@features]
imports = False
chunked-push = False
matrix2 = False
parallel-push = False

[authentication]
email-case-sensitivity = no
----

No detallaremos el significado de cada uno de los flags, pero hay que observar que se trata de un fichero
de texto similar a los ficheros `.ini` y a los que usa Git para la configuración. El fichero mostrado 
contiene las opciones globales, que pueden ser sobreescritas por las configuraciones particulares de cada
repositorio, como las que hay en `repos/Talkhouse/p4gf_config`.
Si abrimos este fichero veremos una sección `[@repo]`, que contiene ajustes diferentes a los valores
globales. También hay secciones como:

[source,ini]
----
[Talkhouse-master]
git-branch-name = master
view = //depot/Talkhouse/main-dev/... ...
----

Este es el mapeo entre una rama de Perforce y una de Git. La sección se puede llamar como queramos,
siempre que el nombre sea único. `git-branch-name` nos permite convertir una ruta a depósito a un nombre
más adecuado para Git. El ajuste `view` controla cómo los ficheros de Perforce son mapeados en un
repositorio Git, usando la sintaxis estándar para vistas de mapeo. Se pueden especificar más de un
mapeo, como en este ejemplo:

[source,ini]
----
[multi-project-mapping]
git-branch-name = master
view = //depot/project1/main/... project1/...
       //depot/project2/mainline/... project2/...
----

De este modo, si el mapeo del espacio de trabajo incluye cambios en la estructura de los directorios, se
puede replicar en un repositorio Git.

El último fichero que veremos es `users/p4gf_usermap`, que mapea usuarios de Perforce a usuarios de git,
y que probablemente no necesitemos usar. Cuando se convierte un cambio en Perforce a un cambio en Git, el
comportamiento predeterminado de Git Fusion es buscar el usuario de Perforce y usar como autor del
cambio (commiter) el correo electrónico y el nombre. En el sentido opuesto, lo que se hace es buscar
el usuario Perforce cuyo correo electrónico coincida con el del cambio y enviar el cambio a Perforce con
ese usuario (con los permisos que le correspondan). En la mayoría de los casos, este comportamiento es
el adecuado. Consideremos el siguiente fichero de mapeo:

[source]
----
john john@example.com "John Doe"
john johnny@appleseed.net "John Doe"
bob employeeX@example.com "Anon X. Mouse"
joe employeeY@example.com "Anon Y. Mouse"
----

Cada línea tiene el formato `<usuario> <correo> "<nombre completo"`, y crea un mapeo único de usuarios.
Las primeras dos líneas mapea dos direcciones de correo diferentes a la misma cuenta de Perforce. Esto es
útil si hemos hecho cambios con diferentes direcciones de correo (o bien la hemos cambiado en el transcurso
del trabajo), pero queremos mapearla a un solo usuario. Cuando se crea un commit de Git desde un cambio
en Perforce, se usa la primera coincidencia encontrada en el fichero anterior para la información de
autoría en Git.

Las dos últimas líneas enmascaran los nombres reales de Bob y Joe, y sus direcciones de correo, de los
commits de Git que se creen. Esto está bien para liberar parte del código de un proyecto interno, pero no se
quiere publicar información interna de los empleados. Observar que las direcciones de correo y los nombres
completos deben ser únicos, a menos que queramos que los commits de Git sean atribuidos a un solo autor
ficticio.

====== Flujos de trabajo

Perforce Git Fusion es un puente de doble sentido entre Perforce y Git. Veamos cómo se siente trabajar
desde el lado Git. Vamos a asumir que hemos mapeado el proyecto ``Jam'' usando un fichero de configuración
similar al visto anteriormente, con lo que podemos clonarlo así:

[source,console]
----
$ git clone https://10.0.1.254/Jam
Cloning into 'Jam'...
Username for 'https://10.0.1.254': john
Password for 'https://ben@10.0.1.254':
remote: Counting objects: 2070, done.
remote: Compressing objects: 100% (1704/1704), done.
Receiving objects: 100% (2070/2070), 1.21 MiB | 0 bytes/s, done.
remote: Total 2070 (delta 1242), reused 0 (delta 0)
Resolving deltas: 100% (1242/1242), done.
Checking connectivity... done.
$ git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master
  remotes/origin/rel2.1
$ git log --oneline --decorate --graph --all
* 0a38c33 (origin/rel2.1) Create Jam 2.1 release branch.
| * d254865 (HEAD, origin/master, origin/HEAD, master) Upgrade to latest metrowerks on Beos -- the Intel one.
| * bd2f54a Put in fix for jam's NT handle leak.
| * c0f29e7 Fix URL in a jam doc
| * cc644ac Radstone's lynx port.
[...]
----

La primera vez que lo hacemos tarda un poco, ya que Git Fusion estará convirtiendo todos los cambios del
historial de Perforce en commits de Git. Esto tiene lugar en el servidor, lo que lo hace relativamente
rápido, pero si el historial es grande tardará un poco. Las siguientes veces que se extraiga el 
repositorio, hará una conversión incremental, por lo que se acercará a la velocidad nativa de Git.

Como se puede ver, el repositorio es similar a cualquier otro repositorio Git con el que queramos
trabajar. Hay tres ramas, y Git crea la rama `master` local que corresponde con la remota `origin/master`.
Hagamos algo de trabajo, creando un par de nuevos commits:

[source,console]
----
# ...
$ git log --oneline --decorate --graph --all
* cfd46ab (HEAD, master) Add documentation for new feature
* a730d77 Whitespace
* d254865 (origin/master, origin/HEAD) Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]
----

Tras estos dos commits, veamos si alguien más ha estado trabajando con el código:

[source,console]
----
$ git fetch
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 2), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://10.0.1.254/Jam
   d254865..6afeb15  master     -> origin/master
$ git log --oneline --decorate --graph --all
* 6afeb15 (origin/master, origin/HEAD) Update copyright
| * cfd46ab (HEAD, master) Add documentation for new feature
| * a730d77 Whitespace
|/
* d254865 Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]
----

Parece ser que alguien ha tocado algo. No lo sabríamos desde esta vista, pero el commit `6afeb15` ha sido
creado con un cliente Perforce. Pero se ve como cualquier otro commit de Git. Veamos ahora cómo maneja
el servidor Perforce con los commit con fusión (merge):

[source,console]
----
$ git merge origin/master
Auto-merging README
Merge made by the 'recursive' strategy.
 README | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git push
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 6), reused 0 (delta 0)
remote: Perforce: 100% (3/3) Loading commit tree into memory...
remote: Perforce: 100% (5/5) Finding child commits...
remote: Perforce: Running git fast-export...
remote: Perforce: 100% (3/3) Checking commits...
remote: Processing will continue even if connection is closed.
remote: Perforce: 100% (3/3) Copying changelists...
remote: Perforce: Submitting new Git commit objects to Perforce: 4
To https://10.0.1.254/Jam
   6afeb15..89cba2b  master -> master
----

Han funcionado las cosas con Commit. Si miramos el historial del fichero `README` desde el punto de
vista de Perforce, usando la función de gráfica de revisiones de `p4v`:

.Gráfica de revisiones de Perforce resultante tras el Git push.
image::images/git-fusion-perforce-graph.png[Gráfica de revisiones de Perforce resultante tras el Git push.]

Si es la primera vez que vemos esto, puede resultar algo confuso, pero en realidad muestra conceptualmente
lo mismo que un visor gráfico del historial de Git. Aquí estamos viendo el historial del fichero `README`,
por lo que el árbol del lado superior izquierdo solo muestra este fichero en su rama. En el lado
superior derecho, tenemos la gráfica de cómo se relacionan las diferentes revisiones del fichero, y abajo a la derecha, una visión general del gráfico. EL resto de la vista es el detalle de la revisión
seleccionada (`2` en nuestro caso).

Hay que observar que el gráfico se parece al del historial en Git. Perforce no tiene una rama nombrada
para almacenar los commits `1` y `2`, luego se ha hecho una rama ``anónima'' en el directorio
`.git-fusion` para darle el soporte. Esto también sucederá con ramas Git con nombre que no correspondan
a una rama con nombre de Perforce (y posteriormente podremos mapear la rama de Git con la de Perforce
utilizando el fichero de configuración).

Casi todo esto ocurre entre bastidores, pero el resultado final es que una persona del equipo puede
usar Git y la otra Perforce, y ninguna de ellas sabrá lo que usa la otra.

====== Git-Fusion: Resumen

Si tenemos acceso (o podemos conseguirlo) a un servidor Perforce, Git Fusion es una buena forma de
hacer que Git y Perforce se entiendan. Hay algo de configuración entre medias, pero la curva
de aprendizaje es sencilla. Esta es una de las pocas secciones de este capítulo donde no es necesario
pedir precauciones al usar las características avanzadas de Git con un servidor de otro tipo, ya que
Git Fusion hace las cosas muy fáciles, casi como si estuviésemos trabajando con un servidor nativo de Git.
Se pueden usar submódulos de Git (aunque resultarán extraños a los usuarios de Perforce) y fusionar ramas
(esto se verá como una integración en el lado de Perforce).

Pero si no podemos convencer al administrador de Perforce que instale Git Fusion, aun podemos usar
Git contra Perforce de otra forma.

===== Git-p4

(((comandos de git, p4)))
Git-p4 es un puente bidireccional entre Git y Perforce.
Se ejecuta dentro del repositorio Git, por lo que no es necesario el acceso al servidor Perforce (aunque
sí las credenciales de usuario). Git-p4 no es tan flexible o completo como Git Fusion, pero permite hacer
casi todo, sin necesidad de instalar nada en el servidor.

[NOTE]
======
Es necesario tener acceso al ejecutable `p4` en algún lugar del `PATH` para poder trabajar con git-p4.
En este momento, se puede obtener libremente en http://www.perforce.com/downloads/Perforce/20-User[].
======

====== Puesta en marcha

Para demostrar el funcionamiento, usaremos el servidor Perforce proporcionado por la máquina virtual
usada en la sección anterior, pero no usaremos las funcionalidades de Git-Fusion, sino que iremos
directamente al control de versiones Perforce.

Para poder usar el comando `p4`, que utiliza git-p4, necesitamos ajustar un par de variables de entorno:

[source,console]
----
$ export P4PORT=10.0.1.254:1666
$ export P4USER=john
----

====== Comienzo

Al igual que en Git, lo primero a hacer es clonar el repositorio:

[source,console]
----
$ git p4 clone //depot/www/live www-shallow
Importing from //depot/www/live into www-shallow
Initialized empty Git repository in /private/tmp/www-shallow/.git/
Doing initial import of //depot/www/live/ from revision #head into refs/remotes/p4/master
----

Esto crea un clon ``superficial'' (``shallow clone'') de Git, es decir, solo se obtiene la última revisión
Perforce, ya que recordemos que este software no facilita todas las revisiones al cliente. Esto es
suficiente para trabajar con Git como cliente de Perforce, aunque para otros propósitos no.

Una vez que ha terminado, tenemos un repositorio Git completamente funcional:

[source,console]
----
$ cd myproject
$ git log --oneline --all --graph --decorate
* 70eaf78 (HEAD, p4/master, p4/HEAD, master) Initial import of //depot/www/live/ from the state at revision #head
----

Observar que hay un remoto llamado ``p4'' para el servidor Perforce, pero para lo demás es similar a un
clonado estándar. 
Note how there's a ``p4'' remote for the Perforce server, but everything else looks like a standard clone.
Esto es algo engañoso, ya que no es un remoto real.

[source,console]
----
$ git remote -v
----

Este repositorio no tiene remotos. Git-p4 ha creado algunas referencias que representan el estado del
servidor, y son similares a referencias remotas de `git log`, pero no están gestionadas por Git y por tanto
no podemos subir (push) cambios con ellas.

====== Flujo de Trabajo

Realicemos algo de trabajo. Asumiendo que hemos implementado alguna característica importante en el código,
y estamos preparados para mostrar el trabajo al resto del equipo.

[source,console]
----
$ git log --oneline --all --graph --decorate
* 018467c (HEAD, master) Change page title
* c0fb617 Update link
* 70eaf78 (p4/master, p4/HEAD) Initial import of //depot/www/live/ from the state at revision #head
----

Hemos realizado dos commits que consideramos preparados para enviar al servidor Perforce. Comprobemos si
alguien ha modificado algo previamente:

[source,console]
----
$ git p4 sync
git p4 sync
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12142 (100%)
$ git log --oneline --all --graph --decorate
* 75cd059 (p4/master, p4/HEAD) Update copyright
| * 018467c (HEAD, master) Change page title
| * c0fb617 Update link
|/
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

Se ve que `master` y `p4/master` han tomado caminos divergentes. El sistema de ramas de Perforce no es
muy similar al de Git, por lo que enviar los commits para una fusión (merge) no tiene sentido. Git-p4
recomienda reorganizar (rebase) los commits, para lo que tiene un comando:

[source,console]
----
$ git p4 rebase
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
No changes to import!
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
Applying: Update link
Applying: Change page title
 index.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
----

Como se ve, `git p4 rebase` es en realidad un `git p4 sync` seguido de `git rebase p4/master`. Es algo más,
sobre todo si trabajamos con múltiples ramas, pero es una buena aproximación.

Ahora el historial es lineal de nuevo, y podemos enviar nuestros cambios a Perforce. El comando
`git p4 submit` intentará crear una nueva revisión en Perforce para cada commit. Al ejecutarlo lanzará
el editor para documentar los cambios:

[source,console]
----
# A Perforce Change Specification.
#
#  Change:      The change number. 'new' on a new changelist.
#  Date:        The date this specification was last modified.
#  Client:      The client on which the changelist was created.  Read-only.
#  User:        The user who created the changelist.
#  Status:      Either 'pending' or 'submitted'. Read-only.
#  Type:        Either 'public' or 'restricted'. Default is 'public'.
#  Description: Comments about the changelist.  Required.
#  Jobs:        What opened jobs are to be closed by this changelist.
#               You may delete jobs from this list.  (New changelists only.)
#  Files:       What opened files from the default changelist are to be added
#               to this changelist.  You may delete files from this list.
#               (New changelists only.)

Change:  new

Client:  john_bens-mbp_8487

User: john

Status:  new

Description:
   Update link

Files:
   //depot/www/live/index.html   # edit


######## git author ben@straub.cc does not match your p4 account.
######## Use option --preserve-user to modify authorship.
######## Variable git-p4.skipUserNameCheck hides this message.
######## everything below this line is just the diff #######
--- //depot/www/live/index.html  2014-08-31 18:26:05.000000000 0000
+++ /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/index.html   2014-08-31 18:26:05.000000000 0000
@@ -60,7 +60,7 @@
 </td>
 <td valign=top>
 Source and documentation for
-<a href="http://www.perforce.com/jam/jam.html">
+<a href="jam.html">
 Jam/MR</a>,
 a software build tool.
 </td>
----

Esto es casi lo mismo que lo que se ve cuando se hace `p4 submit`.  Git-p4 intenta proponer los datos
del cambio según los datos que tiene, pero puede suceder que queramos cambiarlos.
Por ejemplo, si el commit de Git que estamos importando tiene un autor que no tiene un usuario Perforce
asociado, puede ser que queramos mantener dicho autor (y no hacerlo como si fuera nuestro).

Git-p4 habrá importado el mensaje del commit de Git como parte del cambio Perforce, por lo que sería
suficiente con salvar y salir, dos veces (una por cada commit). La salida de los comandos será similar
a esta:

[source,console]
----
$ git p4 submit
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Synchronizing p4 checkout...
... - file(s) up-to-date.
Applying dbac45b Update link
//depot/www/live/index.html#4 - opened for edit
Change 12143 created with 1 open file(s).
Submitting change 12143.
Locking 1 files ...
edit //depot/www/live/index.html#5
Change 12143 submitted.
Applying 905ec6a Change page title
//depot/www/live/index.html#5 - opened for edit
Change 12144 created with 1 open file(s).
Submitting change 12144.
Locking 1 files ...
edit //depot/www/live/index.html#6
Change 12144 submitted.
All commits applied!
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12144 (100%)
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
$ git log --oneline --all --graph --decorate
* 775a46f (HEAD, p4/master, p4/HEAD, master) Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

El resultado es parecido a si hubiéramos hecho un `git push`, que es lo más análogo a lo que ha ocurrido
realmente.

Obsérvese que durante el proceso, cada commit de Git se traduce a un cambio Perforce; si queremos agruparlo
en un solo cambio, se puede hacer mediante una reorganización interactiva antes de ejecutar
`git p4 submit`. Obsérvese también que los hashes SHA-1 de todos los commits enviados como cambios
Perforce habrán cambiado; esto es porque git-p4 añade una línea al final de cada commit que convierte:

[source,console]
----
$ git log -1
commit 775a46f630d8b46535fc9983cf3ebe6b9aa53145
Author: John Doe <john@example.com>
Date:   Sun Aug 31 10:31:44 2014 -0800

    Change page title

    [git-p4: depot-paths = "//depot/www/live/": change = 12144]
----

Veamos qué sucede si intentamos enviar un commit de fusión. Veamos primero la situación:

[source,console]
----
$ git log --oneline --all --graph --decorate
* 3be6fd8 (HEAD, master) Correct email address
*   1dcbf21 Merge remote-tracking branch 'p4/master'
|\
| * c4689fc (p4/master, p4/HEAD) Grammar fix
* | cbacd0a Table borders: yes please
* | b4959b6 Trademark
|/
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

El historial de Git y Perforce divergen después de 775a46f. El lado Git tiene dos commit, y tras un commit
de fusión con Perforce, hay otro commit. Intentamos enviarlos como un cambio único en el lado Perforce.
Lo que sucede si intentamos enviarlo ahora es:

[source,console]
----
$ git p4 submit -n
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would synchronize p4 checkout in /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would apply
  b4959b6 Trademark
  cbacd0a Table borders: yes please
  3be6fd8 Correct email address
----

El modificador `-n` es una abreviatura de `--dry-run`, que intenta simular el comando y ver qué resultado
daría. En este caso, parece que hayamos hecho tres cambios de Perforce, que corresponden a tres
commits sin fusión que no existen en el servidor Perforce. Esto suena justo lo que queremos, veamos qué
sucede al ejecutarlo:

[source,console]
----
$ git p4 submit
[…]
$ git log --oneline --all --graph --decorate
* dadbd89 (HEAD, p4/master, p4/HEAD, master) Correct email address
* 1b79a80 Table borders: yes please
* 0097235 Trademark
* c4689fc Grammar fix
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

El historial se vuelve lineal, justo como si hubiéramos reorganizado antes de enviar (que es, de hecho,
exactamente lo que ha ocurrido). Esto significa que podemos crear, trabajar y fusionar ramas desde Git
sin preocuparnos de que el historial sea incompatible en el lado Perforce. Si se puede reorganizar, 
se puede contribuir a un repositorio Perforce.

[[_git_p4_branches]]
====== Ramas

Si el proyecto Perforce tiene múltiples ramas, no es mucho problema; git-p4 puede gestionarlas de una
forma que recuerda a Git. Por ejemplo, supongamos que el depósito Perforce tiene esto:

[source]
----
//depot
  └── project
      ├── main
      └── dev
----

Y supongamos que tenemos nosotros una rama `dev`, con una especificación como esta:

[source]
----
//depot/project/main/... //depot/project/dev/...
----

Git-p4 puede detectar automáticamente la situación y hacer lo correcto:

[source,console]
----
$ git p4 clone --detect-branches //depot/project@all
Importing from //depot/project@all into project
Initialized empty Git repository in /private/tmp/project/.git/
Importing revision 20 (50%)
    Importing new branch project/dev

    Resuming with change 20
Importing revision 22 (100%)
Updated branches: main dev
$ cd project; git log --oneline --all --graph --decorate
* eae77ae (HEAD, p4/master, p4/HEAD, master) main
| * 10d55fb (p4/project/dev) dev
| * a43cfae Populate //depot/project/main/... //depot/project/dev/....
|/
* 2b83451 Project init
----

Obsérvese la parte ``@all'' en el path del depósito; esto indica a git-p4 que haga un clonado no solamente
del último cambio de ese árbol, sino de todos los que hayan afectado a esos paths. Esto es más cercano
al concepto de clonado de Git, pero si estamos trabajando en un proyecto con gran historial, tardará
un rato.

La opción `--detect-branches` indica a git-p4 que mapee las ramas de Perforce a ramas de Git. Si sus
mapeos no están presentes en el servidor Perforce podemos decir a git-p4 cuáles son los mapeos y obtener
el mismo resultado:

[source,console]
----
$ git init project
Initialized empty Git repository in /tmp/project/.git/
$ cd project
$ git config git-p4.branchList main:dev
$ git clone --detect-branches //depot/project@all .
----

Al poner la variable `git-p4.branchList` al valor `main:dev`, diremos a git-p4 que ``main'' y
``dev'' son ambos ramas, y la segunda es hija de la primera.

Si hacemos ahora un `git checkout -b dev p4/project/dev` y hacemos varios commits, git-p4 sabrá a qué
rama subirla al hacer `git p4 submit`.
Pero, git-p4 no puede mezclar clones superfiales y ramas múltiples; si tenemos un proyecto grande y
queremos trabajar en más de una rama, tendremos que hacer `git p4 clone` por cada rama que queramos
modificar.

Para crear e integrar ramas, hay que usar un cliente Perforce. Git-p4 solo puede sincronizar o enviar hacia
ramas existentes, y solo un cambio linear a la vez. Si fusionamos dos ramas en Git e intentamos crear un
nuevo cambio Perforce, perderemos los metadatos sobre ramas involucradas en la integración.

===== Resumen: Git y Perforce

Git-p4 hace posible usar un flujo de trabajo git con un servidor Perforce. Sin embargo, es importante
recordar que Perforce es el responsable del código y usamos Git solo para trabajo local. Hay que tener
cuidado al compartir commits de Git; si tenemos un remoto que usan otras personas, no debe enviarse
commits que no hayan sido enviardo aun al servidor Perforce.

Si queremos que sea indistinto usar clientes Git y Perforce, es mejor convencer al administrador de que
instale Git Fusion en el servidor.
