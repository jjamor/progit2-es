==== Git y Mercurial

(((Interoperabilidad con otros VCS,, Mercurial)))
(((Mercurial)))
El mundo del control de versiones es bastante amplio. De hecho hay otros sistemas de control de versiones
populares, cada uno con su propio enfoque en la forma de realizar el control de versiones distribuido.
Además de Git, el más popular es Mercurial, que es muy parecido en muchos aspectos.

La buena noticia es que, si preferimos trabajar en el lado del cliente con Git pero con servidor Mercurial,
tenemos manera de hecerlo. Dado que Git habla a los repositorios de servidor mediante los `remotes`, no
resulta sorprendente que el puente con Mercurial haya sido implementado como script de ayuda de remoto.
El proyecto se llama git-remote-hg, y se puede obtener en https://github.com/felipec/git-remote-hg[].

===== git-remote-hg

Lo primero es instalar git-remote-hg.
Para ello, nos lo bajamos con una orden similar a:

[source,console]
----
$ curl -o ~/bin/git-remote-hg \
  https://raw.githubusercontent.com/felipec/git-remote-hg/master/git-remote-hg
$ chmod +x ~/bin/git-remote-hg
----

…suponiendo que `~/bin` está en nuestro `$PATH`.
Git-remote-hg necesita que esté instalada la biblioteca de Python llamada `mercurial`.
Si tenemos instalado Python, es sencillo:

[source,console]
----
$ pip install mercurial
----

(Si no está instalado, hay que instalarlo, por ejemplo desde https://www.python.org/[])

Además, hay que instalar el cliente Mercurial.
Podemos ir a http://mercurial.selenic.com/[] e instalarlo si aun no lo tenemos.

A partir de ahora estamos preparados. Necesitamos un repositorio Mercurial donde tengamos permiso 
para subir cambios (push). Por suerte, cada repositorio de Mercurial puede configurarse de esta forma, por
lo que para probar podemos clonar el repositorio de aprendizaje "hello world" como sigue:

[source,console]
----
$ hg clone http://selenic.com/repo/hello /tmp/hello
----

===== Preparación

Una vez que tenemos un repositorio ``servidor'', podemos seguir un flujo de trabajo típico. Como veremos,
Git y Mercurial son muy parecidos, por lo que habrá pocos problemas.

Como en Git, lo primero que hacemos es clonar:

[source,console]
----
$ git clone hg::/tmp/hello /tmp/hello-git
$ cd /tmp/hello-git
$ git log --oneline --graph --decorate
* ac7955c (HEAD, origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master, master) Create a makefile
* 65bb417 Create a standard "hello, world" program
----

Vemos que se utiliza el comando `git clone` directamente. Esto es porque git-remote-hg trabaja a bajo nivel,
con un mecanismo similar al protocolo de Git con HTTP/S (remote helper). Dado que Git y Mercurial están
diseñados para que cada cliente tenga su propia copia de todo el repositorio, el comando anterior hace un
clon completo del proyecto, incluyendo toda la historia, y lo hace de forma rápida.

El comando log muestra dos cambios, el último apuntando a una serie de referencias. Pero no todas las
conocíamos, si miramos la carpeta `.git`:

[source,console]
----
$ tree .git/refs
.git/refs
├── heads
│   └── master
├── hg
│   └── origin
│       ├── bookmarks
│       │   └── master
│       └── branches
│           └── default
├── notes
│   └── hg
├── remotes
│   └── origin
│       └── HEAD
└── tags

9 directories, 5 files
----

Git-remote-hg intenta hacer las cosas parecidas a como las hace Git, pero realmente realiza un mapeo
entre remotos Mercurial y remotos Git. La carpeta `refs/hg` es donde las referencias remotas reales
se almacenan. Por ejemplo, `refs/hg/origin/branches/default` es una referencia de Git que contiene el
SHA ``ac6955c``, que es el commit al que apunta `master`.
Digamos que `refs/hg` es un falso `refs/remotes/origin`, pero con la distinción entre marcadores (bookmarks)
y ramas (branches).

El fichero `notes/hg` es el punto de partida para saber cómo mapear el hash del commit de Git al
identificador de cambio usado en Mercurial (changeset Id). Si miramos un poco:

[source,console]
----
$ cat notes/hg
d4c10386...

$ git cat-file -p d4c10386...
tree 1781c96...
author remote-hg <> 1408066400 -0800
committer remote-hg <> 1408066400 -0800

Notes for master

$ git ls-tree 1781c96...
100644 blob ac9117f...	65bb417...
100644 blob 485e178...	ac7955c...

$ git cat-file -p ac9117f
0a04b987be5ae354b710cefeba0e2d9de7ad41a9
----

Vemos que `refs/notes/hg` apunta a un árbol,que es una lista de objetos con nombres. El comando
`git ls-tree` muestra el modo, tipo, hash del objeto y nombre del fichero para los elementos del árbol.
Una vez que entramos en uno de los elementos, vemos que dentro hay un objeto binario (blob) llamado
``ac9117f'' (el hash del commit apuntado por `master`), que contiene ``0a04b98'' (el identificador
del cambio en Mercurial en su rama `default`).

La buena noticia es que no tenemos que preocuparnos por estos detalles. El flujo de trabajo típico no será
muy distinto a cuando se trabaja con un remoto de Git.

Hay otra cosa a tener en cuenta: los ficheros a ignorar. Mercurial y Git usan un mecanismo general, pero
no vamos a querer subir ficheros `.gitignore` a Mercurial. Tendremos que hacer lo siguiente con los ficheros
para ignorar:

[source,console]
----
$ cp .hgignore .git/info/exclude
----

El fichero `.git/info/exclude` es justo lo mismo que `.gitignore`, pero no se incluye en los commits, por lo
que evitaremos subirlo al remoto.


===== Flujo de Trabajo

Si suponemos que se han realizado algunos cambios (commits) sobre la rama `master`, y estamos listos
para enviarlos (push) al repositorio, veremos en primer lugar los cambios:

[source,console]
----
$ git log --oneline --graph --decorate
* ba04a2a (HEAD, master) Update makefile
* d25d16f Goodbye
* ac7955c (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Create a makefile
* 65bb417 Create a standard "hello, world" program
----

Nuestra rama `master` tiene dos commits por delante de `origin/master`, es decir, existen solo en nuestra
copia local. Veremos si alguien ha trabajado a la vez en el repositorio:

[source,console]
----
$ git fetch
From hg::/tmp/hello
   ac7955c..df85e87  master     -> origin/master
   ac7955c..df85e87  branches/default -> origin/branches/default
$ git log --oneline --graph --decorate --all
* 7b07969 (refs/notes/hg) Notes for default
* d4c1038 Notes for master
* df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation
| * ba04a2a (HEAD, master) Update makefile
| * d25d16f Goodbye
|/
* ac7955c Create a makefile
* 65bb417 Create a standard "hello, world" program
----

Al usar la opción `--all`, vemos que se utiliza la referencia ``notes'', pero podemos ignorarla. El resto
es lo que esperábamos; `origin/master` tiene un commit más, y nuestro historial tiene otro camino.
A diferencia de otros sistemas vistos, Mercurial sí puede gestionar las fusiones, por lo que no tendremos
muchos problemas.

[source,console]
----
$ git merge origin/master
Auto-merging hello.c
Merge made by the 'recursive' strategy.
 hello.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git log --oneline --graph --decorate
*   0c64627 (HEAD, master) Merge remote-tracking branch 'origin/master'
|\
| * df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation
* | ba04a2a Update makefile
* | d25d16f Goodbye
|/
* ac7955c Create a makefile
* 65bb417 Create a standard "hello, world" program
----

Perfecto. Todo sale correctamente y podemos compartir el trabajo con el equipo:

[source,console]
----
$ git push
To hg::/tmp/hello
   df85e87..0c64627  master -> master
----

Ya está todo. Si miramos el repositorio Mercurial, veremos que ha ocurrido lo que esperábamos:

[source,console]
----
$ hg log -G --style compact
o    5[tip]:4,2   dc8fa4f932b8   2014-08-14 19:33 -0700   ben
|\     Merge remote-tracking branch 'origin/master'
| |
| o  4   64f27bcefc35   2014-08-14 19:27 -0700   ben
| |    Update makefile
| |
| o  3:1   4256fc29598f   2014-08-14 19:27 -0700   ben
| |    Goodbye
| |
@ |  2   7db0b4848b3c   2014-08-14 19:30 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard "hello, world" program
----

El cambio llamado _2_ fue hecho por Mercurial, mientras que los cambios _3_ y _4_ fueron realizados por
git-remote-hg, al realizar el push desde Git.

===== Ramas y Marcadores

En Git solo tenemos una clase de ramas: referencias que se mueven cuando se practican commits. En
Mercurial, esto es conocido como ``bookmark'' (marcador) pero es lo mismo que una rama de Git.

El concepto de ``branch'' (rama) en Mercurial es más complicado. La rama se guarda con el cambio, es decir,
se quedará en el historial del repositorio.

Un ejemplo con la rama `develop`:

[source,console]
----
$ hg log -l 1
changeset:   6:8f65e5e02793
branch:      develop
tag:         tip
user:        Ben Straub <ben@straub.cc>
date:        Thu Aug 14 20:06:38 2014 -0700
summary:     More documentation
----

Observemos la línea que empieza con ``branch''. Git realmente no puede imitar esto (ni tampoco lo necesita,
ambos tipos de ramas se pueden representar con una ref de Git), pero git-remote-hg necesita entender
la diferencia, ya que Mercurial lo tiene en cuenta.

Crear un marcador de Mercurial es tan simple como crear ramas de Git. En Git haremos:

[source,console]
----
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ git push origin featureA
To hg::/tmp/hello
 * [new branch]      featureA -> featureA
----

Esto es todo. En el lado de Mercurial se verá:

[source,console]
----
$ hg bookmarks
   featureA                  5:bd5ac26f11f9
$ hg log --style compact -G
@  6[tip]   8f65e5e02793   2014-08-14 20:06 -0700   ben
|    More documentation
|
o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben
|\     Merge remote-tracking branch 'origin/master'
| |
| o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben
| |    update makefile
| |
| o  3:1   318914536c86   2014-08-14 20:00 -0700   ben
| |    goodbye
| |
o |  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard "hello, world" program
----

Nótese la nueva etiqueta `[featureA]` en la revisión 5.
Actúa igual que las ramas de Git, con una excepción: no se puede borrar un marcador desde el lado de Git
(esto es una limitación de los helpers remotos).

Se puede trabajar también con las ramas ``complicadas'' de Mercurial, simplemente poniendo
una rama en el espacio de nombres `branches`:

[source,console]
----
$ git checkout -b branches/permanent
Switched to a new branch 'branches/permanent'
$ vi Makefile
$ git commit -am 'A permanent change'
$ git push origin branches/permanent
To hg::/tmp/hello
 * [new branch]      branches/permanent -> branches/permanent
----

En el lado Mercurial veremos:

[source,console]
----
$ hg branches
permanent                      7:a4529d07aad4
develop                        6:8f65e5e02793
default                        5:bd5ac26f11f9 (inactive)
$ hg log -G
o  changeset:   7:a4529d07aad4
|  branch:      permanent
|  tag:         tip
|  parent:      5:bd5ac26f11f9
|  user:        Ben Straub <ben@straub.cc>
|  date:        Thu Aug 14 20:21:09 2014 -0700
|  summary:     A permanent change
|
| @  changeset:   6:8f65e5e02793
|/   branch:      develop
|    user:        Ben Straub <ben@straub.cc>
|    date:        Thu Aug 14 20:06:38 2014 -0700
|    summary:     More documentation
|
o    changeset:   5:bd5ac26f11f9
|\   bookmark:    featureA
| |  parent:      4:0434aaa6b91f
| |  parent:      2:f098c7f45c4f
| |  user:        Ben Straub <ben@straub.cc>
| |  date:        Thu Aug 14 20:02:21 2014 -0700
| |  summary:     Merge remote-tracking branch 'origin/master'
[...]
----

La rama ``permanent'' se guardó con el changeset _7_.

En el ladp Git, se trabaja igual con ambos tipos de rama: hacer checkout, commits, fetch, merge, push, pull.
Una cosa que no soporta Mercurial es cambiar la historia, tan solo permite añadir. Así que cuando se hace
una reorganización interactiva y un push forzado veremos en Mercurial:

[source,console]
----
$ hg log --style compact -G
o  10[tip]   99611176cbc9   2014-08-14 20:21 -0700   ben
|    A permanent change
|
o  9   f23e12f939c3   2014-08-14 20:01 -0700   ben
|    Add some documentation
|
o  8:1   c16971d33922   2014-08-14 20:00 -0700   ben
|    goodbye
|
| o  7:5   a4529d07aad4   2014-08-14 20:21 -0700   ben
| |    A permanent change
| |
| | @  6   8f65e5e02793   2014-08-14 20:06 -0700   ben
| |/     More documentation
| |
| o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben
| |\     Merge remote-tracking branch 'origin/master'
| | |
| | o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben
| | |    update makefile
| | |
+---o  3:1   318914536c86   2014-08-14 20:00 -0700   ben
| |      goodbye
| |
| o  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard "hello, world" program
----

Los cambios changeset _8_, _9_ y _10_ han sido creados y pertenecen a la rama `permanent`, pero los
cambios anteriores permanecen. Esto puede parecer muy confuso a los que usan Mercurial, por lo que 
tenemos que intentar evitarlo.


===== Resumen

Git y Mercurial son lo suficientemente parecidos como para que trabajar con ambos no sea muy doloroso.
Si evitamos cambiar el historial (como se recomienda en generao), no debería ser un problema el trabajar
con Git contra repositorios Mercurial.
